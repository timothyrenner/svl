?start: visualization

?visualization: datasets charts

datasets: "DATASETS" dataset+

?dataset: file_dataset | sql_dataset

file_dataset: CNAME ESCAPED_STRING

sql_dataset: CNAME "SQL"i ESCAPED_STRING

charts: chart+

vcat: "(" chart+ ")"

hcat: "CONCAT" "(" chart+ ")"

chart: xy_chart | histogram_chart | pie_chart | vcat | hcat

// The XX_property directives include the dimensions, so at least that one
// is required. That will have to be enforced in the compiler though.
xy_chart: markxy data xy_property+

histogram_chart: "HISTOGRAM" data histogram_property+

pie_chart: "PIE" data pie_property+

?xy_property: title | dimensions | filter

?histogram_property: title | axis | histogram_opts | filter

?pie_property: title | axis | pie_opts | filter

title: "TITLE" ESCAPED_STRING

filter: "FILTER" ESCAPED_STRING

markxy: SCATTER | LINE | BAR

data: CNAME

dimensions: (x | y | split_by)+

?histogram_opts: step | bins

?pie_opts: hole

step: "STEP" NUMBER

bins: "BINS" NUMBER

hole: "HOLE" NUMBER

// This allows for both x and y to have aggregations, which results in
// order ambiguity (i.e. which aggregation gets applied first?).
// TODO: Find a way to enforce only one aggregation transformation
// between x and y.
x: "X" axis_spec axis_modifier*

y: "Y" axis_spec axis_modifier*

axis: "AXIS" axis_spec axis_modifier*

?axis_spec: field | transform

?axis_modifier: aggregation | temporal | label

label: "LABEL" ESCAPED_STRING

// For split by temporal is supported irrespective of x and y.
split_by: "SPLIT" "BY" field

field: CNAME

aggregation: COUNT | MIN | MAX | AVG

temporal: "BY" (YEAR | MONTH | DAY | HOUR | MINUTE | SECOND)

transform: "TRANSFORM" ESCAPED_STRING

SCATTER: "SCATTER"

BAR: "BAR"

LINE: "LINE"

HISTOGRAM: "HISTOGRAM"

PIE: "PIE"

COUNT: "COUNT"

MIN: "MIN"

MAX: "MAX"

AVG: "AVG"

YEAR: "YEAR"

MONTH: "MONTH"

DAY: "DAY"

HOUR: "HOUR"

MINUTE: "MINUTE"

SECOND: "SECOND"

%import common.CNAME
%import common.ESCAPED_STRING
%import common.NUMBER
%import common.WS

%ignore WS